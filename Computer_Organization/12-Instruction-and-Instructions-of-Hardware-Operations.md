---
title: 12 Instruction and Instructions of Hardware Operations
date: 2018-08-17 23:14:02
category: Computer_Organization
---
<font size=6>指令，硬件操作指令
<!--more-->

---
<font size=5>计算机的语言 : 指令
<font size=3>如果对一台计算机下指令，你就必须使用它的语言—指令。与子对应的单词就是指令集。如今有许多种机器语言，但是这些语言差异很小，类似于人们的方言一样，只需学习其中一种，其他的机器语言也是手到擒来。我所使用的指令集为19世纪80年代出世的MIPS，一种优秀的指令集。其他的指令集有ARMv7，x86，ARMv8。这些指令集都是大同小异，因为计算机更底层的硬件都基于相同的准则设计，而且许多基础的指令都是必须提供的。除此，计算机的设计者有着相同的目标 : 找到一个语言来简化硬件和编译器的设计同时最大化性能和最小化功耗。
<br/>

<font size=5>硬件的算数操作
<font size=3>所有的计算机都能够执行算数加法操作。下面这条语句就是MIPS汇编语言中的算数加法操作。
```assembly
add a, b, c
```

这条语句将变量b和变量c相加并将结果放入变量a中。这种记法都是固定的，每条MIPS加法命令只执行一个操作，并一定包含三个变量。如果要进行四个变量的加法，就需要下面的语句。其中#是注释的标记。
```assebmly
add a, b, c     #a=b+c
add a, a, d     #a=a+d
add a, a, e     #a=a+e
```

和C语言不同的是，这种语言一行只能有一条指令，同时注释在一行结束。在算数操作中操作数的数字是3，不能多也不能少。这对应着保持硬件简单性的哲学 : 操作数的数量是变化的操作比操作数的数量是固定的操作复杂。这对应着硬件设计的三原则的第一条 : 简单源于规整。
<br/>

<font size=5>硬件的操作数
<font size=3>与高级语言不同的是，算数指令对操作数要求非常严格，它们都必须来自寄存器。寄存器由硬件构成并且数量有限。寄存器是硬件设计中基本元素，在计算机设计完成后对程序员可见的，所以也被认为是构建计算机的砖块。MIPS架构的寄存器大小是32位，所以32位一组又被称为字 (word)。

编程语言的变量与寄存器变量的一个不同之处就在于寄存器的数量是有限的。一般MIPS这一类的现代计算机由32个寄存器。为什么寄存器的数量是受到限制的呢？这就必须提到硬件设计的三原则的第二条 : 越小越快。当寄存器的数量变多，时钟信号就会变长，因为电信号传输更远的距离就会消耗更长的时间。当然31个寄存器不一定比32个寄存器快。这些问题需要设计者认真考虑。所以设计者需要权衡程序对更多寄存器的需求和与之增长的时钟信号时间。同时，我们使用`$`表示寄存器变量。将f=(g+h)-(i+j)翻译为汇编的代码如下
```assembly
add $t0, $s1, $s2   #$t0=g+h $s1=g $s2=h
add $t1, $s3, $s4   #$t1=i+j $s3=i $s4=j
sub $s0, $t0, $t1   #f=$t0-$t1
```
<br/>

<font size=5>存储器操作数
<font size=3>众所周知，编程语言除了数字，字符等普通的变量类型，还有数组等复杂的数据结构。这类数据过大让寄存器无法存储。计算机使用内存来存储访问这类数据。MIPS包含了能将内存的数据载入寄存器的指令，下面的指令将A[8]的数据载入寄存器中。
```assembly
lw $t0, 32($s0)     #$t0=A[8] Memory[$s0]=A
```

在上面的例子中A[8]的位置在$s0+32的原因是因为内存的单位为字节，而MIPS按字编址，字的起始位置必须为4的倍数，所以偏移量是32而不是8。这种要求叫做对其限制 (alignment restriction)。

与载入数据相互补的指令是存数指令，下面指令将寄存器数据存入A[8]中。
```assembly
sw $t0, 32($s0)     #A[8]=$t0 Memory[$s0]=A
```

在编写程序的过程中，我们可能会设置许多的变量，变量的数目远远大于寄存器的数量。我们知道，寄存器在性能，功耗上都优于内存。因此，我们要将最常用的变量保存在寄存器中，剩下的变量放入内存，使用载入和存数指令来在内存和寄存器中移动。将不常用或现在无需使用的变量放入内存的过程叫做寄存器溢出 (spilling registers)。为了实现高性能和低功耗，一套指令集必须要有足够的寄存器并让编译器高效利用寄存器。
<br/>

<font size=5>常数操作数
<font size=3>在程序中经常出现常数操作，比如在数组中移动到下一个元素。MIPS算数指令中拥有使用常数为操作数的指令.

从前面学过的指令来看，我们可以在程序载入后将常数从内存载入寄存器后进行算数操作。但MIPS已经提供了包含常数为操作数的算数指令。下面的指令为寄存器加1。
```assembly
addi $s0, $s0, 1    #$s0=$s0+1
```

因为常数的算数很常见，提供包含常数为操作数的算数指令会比从内存中载入常数更加高效。同时由于常数0起到了简化指令的效果，比如在加法指令中使用常数0可以起到移动操作的效果。在MIPS中提供一个寄存器$zero，这个寄存器恒为0，且这个寄存器的编号也为0。